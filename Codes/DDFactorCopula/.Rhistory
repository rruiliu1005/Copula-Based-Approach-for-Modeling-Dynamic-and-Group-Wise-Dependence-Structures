clusterExport(cl, varlist = c("df", "rho", "nl_x2", "wl", "neg_log_gaussian_likelihood", "gaussian_derivative", "gaussian_derivative_single_obs"))
task = function(i) {
tmp = df[i:(i + period), ]
result_test = nlm(f = neg_log_gaussian_likelihood, p = rho, df = tmp, nl_x2 = nl_x2, wl = wl, gradtol = 1e-5, hessian = FALSE, check.analyticals = FALSE, steptol = 1e-10, iterlim = 10000)
return(list(
likelihood = result_test$minimum,
estimate = result_test$estimate,
gradient = result_test$gradient
))
}
results = pblapply(1:(nrow(df) - period), task, cl = cl)
stopCluster(cl)
likelihoods = sapply(results, function(res) res$likelihood)
estimates = lapply(results, function(res) res$estimate)
gradients = lapply(results, function(res) res$gradient)
return(list(likelihoods = likelihoods, estimates = estimates, gradients = gradients))
}
fit_clayton_copula_time_varying = function(df, theta, period, nl_u2) {
# Number of cores to use
num_cores = detectCores() - 1  # Leave one core free
# Create cluster
cl = makeCluster(num_cores)
# Ensure all libraries are available in worker nodes
clusterEvalQ(cl, {
library(parallel)
library(pbapply)
})
clusterExport(cl, varlist = c("nl_u2", "wl"))
# Define the task to be parallelized
task = function(i, df, theta, period, nl_u2) {
# Define necessary functions within the task
clayton_single_obs_pre = function(u1, u2, theta, d) {
u1_theta = u1^(-theta)
u2_theta = u2^(-theta)
log_u1 = log(u1)
log_u2 = log(u2)
log_u1u2 = log(u1 * u2)
g_theta = u1_theta + u2_theta - 1
A = (theta + 1)
B = g_theta^(-2 - 1 / theta)
C = (u1 * u2)^(-theta - 1)
B_deriv = B * ((1 / theta^2) * log(g_theta) +
(-2 - 1 / theta) * (-u1_theta * log_u1 - u2_theta * log_u2) / g_theta)
C_deriv = -C * log_u1u2
bivariate_copula_values = A * B * C
bivariate_copula_derivatives = B * C + A * (B_deriv * C + B * C_deriv)
multiplication_mat = matrix(bivariate_copula_values, nrow = d, ncol = d)
diag(multiplication_mat) = bivariate_copula_derivatives
numerator = apply(multiplication_mat, 2, prod)
denominator = prod(bivariate_copula_values)
return(list("numerator" = numerator, "denominator" = denominator))
}
clayton_single_obs = function(u1, theta, d, n_nodes, nl_u2, wl) {
tmp = mapply(clayton_single_obs_pre, u2 = nl_u2, MoreArgs = list(u1 = u1, theta = theta, d))
numerator_matrix = do.call(rbind, tmp[1, ])
numerator = apply(numerator_matrix * wl, 2, sum)
denominator = sum(unlist(tmp[2, ]) * wl)
deriv_log_likelihood = numerator / denominator
log_likelihood = log(denominator)
return(list(log_likelihood = log_likelihood, deriv_log_likelihood = deriv_log_likelihood))
}
neg_clayton_loglikelihood = function(df, theta, d, nl_u2, wl) {
if (min(theta) < 1) {
log_likelihood = 9e5
attr(log_likelihood, "gradient") = 1e6 * sign(theta)
return(log_likelihood)
}
out = t(apply(df, 1, clayton_single_obs, theta = theta, d = d, nl_u2 = nl_u2, wl = wl))
log_likelihood = sum(sapply(out, function(x) x$log_likelihood))
derivatives = rowSums(sapply(out, function(x) x$deriv_log_likelihood))
neg_log_likelihood = -1 * log_likelihood
attr(neg_log_likelihood, "gradient") = -1 * derivatives
return(neg_log_likelihood)
}
# Main task logic
tmp = df[i:(i + period), ]
result_test = nlm(f = neg_clayton_loglikelihood, p = theta, df = tmp, d = ncol(df), nl_u2 = nl_u2, wl = wl, gradtol = 1e-2, hessian = FALSE, check.analyticals = FALSE, steptol = 1e-10, iterlim = 10000)
return(list(
likelihood = result_test$minimum,
estimate = result_test$estimate,
gradient = result_test$gradient
))
}
# Parallel execution over chunks with progress tracking using pbapply
results = pblapply(1:(nrow(df) - period), function(i) task(i, df, theta, period, nl_u2), cl = cl)
stopCluster(cl)  # Close the cluster
# Extract results into separate lists
likelihoods = sapply(results, function(res) res$likelihood)
estimates = lapply(results, function(res) res$estimate)
gradients = lapply(results, function(res) res$gradient)
return(list(likelihoods = likelihoods, estimates = estimates, gradients = gradients))
}
fit_gumbel_copula_time_varying = function(df, theta, period, nl_u2, n_nodes) {
# Number of cores to use
num_cores = detectCores() - 1  # Leave one core free
# Create cluster
cl = makeCluster(num_cores)
# Ensure all libraries are available in worker nodes
clusterEvalQ(cl, {
library(parallel)
library(pbapply)
library(pracma)
})
clusterExport(cl, varlist = c("wl", "n_nodes"))
# Define the task to be parallelized
task = function(i, df, theta, period, nl_u2) {
# Define necessary functions within the task
bivariate_gumbel_copula = function(u1, u2, theta){
ln_u1 = log(u1)
ln_u2 = log(u2)
ln_mimus_ln_u1 = log(-ln_u1)
ln_mimus_ln_u2 = log(-ln_u2)
one_over_theta = 1/theta
a_theta = (-ln_u1)^theta
b_theta = (-ln_u2)^theta
A = (a_theta + b_theta)^one_over_theta
B = A + theta - 1
C = A^(1-2*theta)
D = exp(-A)
E = a_theta/ln_u1
FF = b_theta/ln_u2
G = (u1*u2)^-1
out = B*C*D*E*FF*G
deriv_A = A * ((a_theta * ln_mimus_ln_u1 + b_theta * ln_mimus_ln_u2)/(a_theta + b_theta) * one_over_theta - one_over_theta^2*log(a_theta + b_theta))
deriv_B = deriv_A + 1
deriv_C = C * (deriv_A/A * (1-2*theta) - 2*log(A))
deriv_D = D * (-deriv_A)
deriv_E = E*(ln_mimus_ln_u1)
deriv_F = FF*(ln_mimus_ln_u2)
result = deriv_B * C * D * E * FF * G + B * deriv_C * D * E * FF * G + B * C * deriv_D * E * FF * G + B * C * D * deriv_E * FF * G + B * C * D * E * deriv_F * G
return(list(likelihood = out, derivative = result))
}
gumbel_single_obs_pre = function(u1, u2, theta, d){
tmp =  mapply(bivariate_gumbel_copula, u1 = u1, theta = theta, MoreArgs = list(u2 = u2))
bivariate_copula_values = unlist(tmp[1,])
bivariate_copula_derivatives = unlist(tmp[2,])
multiplication_mat = matrix(bivariate_copula_values, nrow = d, ncol = d)
diag(multiplication_mat) = bivariate_copula_derivatives
numerator = apply(multiplication_mat, 2, prod)
denominator = prod(bivariate_copula_values)
return(list("numerator" = numerator, "denominator" = denominator))
}
gumbel_single_obs = function(u1, theta, d, n_nodes){
u1 = as.numeric(u1)
gl = gaussLegendre(n = n_nodes, a = 0, b = 1)
nl_u2 = gl$x
wl = gl$w
tmp = mapply(gumbel_single_obs_pre, u2 = nl_u2, MoreArgs = list(u1 = u1, theta = theta, d))
numerator_matrix = do.call(rbind, tmp[1,])
numerator = apply(numerator_matrix * wl, 2, sum)
denominator = sum(unlist(tmp[2,])*wl)
deriv_log_likelihood = numerator / denominator
log_likelihood = log(denominator)
# attr(log_likelihood, "gradient") = deriv_log_likelihood
# return(log_likelihood)
return(list(log_likelihood = log_likelihood, deriv_log_likelihood = deriv_log_likelihood))
}
neg_gumbel_loglikelihood = function(df, theta, d, n_nodes){
if (min(theta) < 1){
log_likelihood = 9e5
attr(log_likelihood, "gradient") = 1e6*sign(theta)
return(log_likelihood)
}
out = t(apply(df, 1, gumbel_single_obs, theta = theta, d = d, n_nodes = n_nodes))
log_likelihood = sum(sapply(out, function(x) x$log_likelihood))
derivatives = rowSums(sapply(out, function(x) x$deriv_log_likelihood))
neg_log_likelihood = -1 * log_likelihood
attr(neg_log_likelihood, "gradient") = -1 * derivatives
return(neg_log_likelihood)
}
# Main task logic
tmp = df[i:(i + period), ]
result_test = nlm(f = neg_gumbel_loglikelihood, p = theta, df = tmp, d = ncol(df), n_nodes = n_nodes, gradtol = 1e-2, hessian = FALSE, check.analyticals = FALSE, steptol = 1e-10, iterlim = 10000)
return(list(
likelihood = result_test$minimum,
estimate = result_test$estimate,
gradient = result_test$gradient
))
}
# Parallel execution over chunks with progress tracking using pbapply
results = pblapply(1:(nrow(df) - period), function(i) task(i, df, theta, period, n_nodes), cl = cl)
stopCluster(cl)  # Close the cluster
# Extract results into separate lists
likelihoods = sapply(results, function(res) res$likelihood)
estimates = lapply(results, function(res) res$estimate)
gradients = lapply(results, function(res) res$gradient)
return(list(likelihoods = likelihoods, estimates = estimates, gradients = gradients))
}
#' Fit a One-Factor Copula Model With Dynamic Dependence
#'
#' This function fits a one-factor copula model to the given data frame of uniform variables.
#' Supported copulas include 'Gaussian', 'Clayton', 'Gumbel', and 'rGumbel'.
#'
#' @param df A data frame containing uniform variables with \code{nrow(df)}
#' observations and \code{ncol(df)} variables.
#' @param copula A character string specifying the copula to be fitted.
#' Supported values are \code{'Gaussian'}, \code{'Clayton'}, \code{'Gumbel'}, and \code{'rGumbel'}.
#' @param params A list of parameters for the copula model.
#' Default is \code{list(n_nodes = 35, init_val = rep(0.5, ncol(df)), period = 90)} for Gaussian copula,
#' \code{list(n_nodes = 25, init_val = rep(2, ncol(df)), period = 90)} for Clayton, Gumbel and reflected Gumbel copulas
#' .
#' @return A list containing:
#'   \describe{
#'     \item{\code{minimum}}{The estimated minimum of the negative log-likelihood.}
#'     \item{\code{estimate}}{The optimal parameter values.}
#'     \item{\code{gradient}}{The gradient at the estimated minimum.}
#'   }
#' @export
fitOneFactorDynamic <- function(df, copula, params = list()) {
d = ncol(df)
if (copula == 'Gaussian') {
default_params <- list(n_nodes = 35, init_val = rep(0.5, d), period = 90)
params <- modifyList(default_params, params)
n_nodes <- params$n_nodes
init_val <- params$init_val
period <- params$period
gl <- gaussLegendre(n_nodes, 0, 1)
nl_x2 <- qnorm(gl$x)
wl <- gl$w
if (max(abs(init_val)) > 1){
return("invalid copula initial parameters")
}
return(fit_gaussian_copula_time_varying(df = df, rho = init_val,
period = period, n_nodes = n_nodes))
}
else if (copula == 'Clayton'){
default_params <- list(n_nodes = 35, init_val = rep(2, d))
params <- modifyList(default_params, params)
n_nodes <- params$n_nodes
init_val <- params$init_val
period <- params$period
gl = gaussLegendre(n_nodes, 0, 1)
nl_u2 = gl$x
wl = gl$w
if (min(init_val) < 0){
return("invalid copula initial parameters")
}
return(fit_clayton_copula_time_varying(df = df, theta = init_val,
period = period, nl_u2 = nl_u2))
}
else if (copula == 'Gumbel'){
default_params <- list(n_nodes = 35, init_val = rep(2, d))
params <- modifyList(default_params, params)
n_nodes <- params$n_nodes
init_val <- params$init_val
period <- params$period
gl = gaussLegendre(n_nodes, 0, 1)
nl_u2 = gl$x
wl = gl$w
if (min(init_val) < 1){
return("invalid copula initial parameters")
}
return(fit_gumbel_copula_time_varying(df = df, theta = init_val,
period = period, n_nodes = n_nodes))
}
}
devtools::build()
devtools::install()
library(DDFactorCopula)
test_results = fitOneFactorDynamic(df = unif_df[200,1:20], copula = 'Gaussian',
list(n_nodes = 35, init_val = rep(0.5, ncol(df)), period = 90))
test_results = fitOneFactorDynamic(df = unif_df[1:200,1:20], copula = 'Gaussian',
list(n_nodes = 35, init_val = rep(0.5, ncol(df)), period = 90))
test_results = fitOneFactorDynamic(df = unif_df[1:500,1:20], copula = 'Clayton',
list(n_nodes = 35, init_val = rep(0.5, ncol(df)), period = 90))
test_results
df
test_results = fitOneFactorDynamic(df = unif_df[1:200,1:20], copula = 'Gaussian',
list(n_nodes = 35, init_val = rep(0.5, 20), period = 90))
test_results
test_results$estimates
test_results = fitOneFactorDynamic(df = unif_df[1:500,1:20], copula = 'Clayton',
list(n_nodes = 25, init_val = rep(2, 20), period = 90))
?fitOneFactorDynamic
devtools::document()
warnings()
devtools::document()
devtools::build()
devtools::install()
fitOneFactorDynamic
?fitOneFactorDynamic
devtools::build()
devtools::install()
library(DDFactorCopula)
unif_df = read.csv('/Users/ruiliu/Desktop/research/data/unif_df.csv')
################################################
#test base model
test_results = fitOneFactor(df = unif_df[,1:20],copula = "Gaussian",
list(n_nodes = 35))
test_results
################################################
#test dynamic model
test_results = fitOneFactorDynamic(df = unif_df[1:200,1:20], copula = 'Gaussian',
list(n_nodes = 35, init_val = rep(0.5, 20), period = 90))
devtools::build()
devtools::install()
################################################
#test dynamic model
test_results = fitOneFactorDynamic(df = unif_df[1:200,1:20], copula = 'Gaussian',
list(n_nodes = 35, init_val = rep(0.5, 20), period = 90))
devtools::install()
library(DDFactorCopula)
################################################
#test dynamic model
test_results = fitOneFactorDynamic(df = unif_df[1:200,1:20], copula = 'Gaussian',
list(n_nodes = 35, init_val = rep(0.5, 20), period = 90))
devtools::build()
devtools::install()
################################################
#test dynamic model
test_results = fitOneFactorDynamic(df = unif_df[1:200,1:20], copula = 'Gaussian',
list(n_nodes = 35, init_val = rep(0.5, 20), period = 90))
################################################
#test dynamic model
test_results = fitOneFactorDynamic(df = unif_df[1:200,1:20], copula = 'Gaussian',
list(n_nodes = 35, init_val = rep(0.5, 20), period = 90))
devtools::build()
devtools::install()
################################################
#test dynamic model
test_results = fitOneFactorDynamic(df = unif_df[1:200,1:20], copula = 'Gaussian',
list(n_nodes = 35, init_val = rep(0.5, 20), period = 90))
library(DDFactorCopula)
################################################
#test dynamic model
test_results = fitOneFactorDynamic(df = unif_df[1:200,1:20], copula = 'Gaussian',
list(n_nodes = 35, init_val = rep(0.5, 20), period = 90))
devtools::build()
devtools::install()
library(DDFactorCopula)
################################################
#test dynamic model
test_results = fitOneFactorDynamic(df = unif_df[1:200,1:20], copula = 'Gaussian',
list(n_nodes = 35, init_val = rep(0.5, 20), period = 90))
################################################
#test dynamic model
test_results = fitOneFactorDynamic(df = unif_df[1:200,1:20], copula = 'Gaussian',
list(n_nodes = 35, init_val = rep(0.5, 20), period = 90))
devtools::build()
devtools::install()
library(DDFactorCopula)
################################################
#test dynamic model
test_results = fitOneFactorDynamic(df = unif_df[1:200,1:20], copula = 'Gaussian',
list(n_nodes = 35, init_val = rep(0.5, 20), period = 90))
devtools::install()
devtools::build()
devtools::install()
library(DDFactorCopula)
################################################
#test dynamic model
test_results = fitOneFactorDynamic(df = unif_df[1:200,1:20], copula = 'Gaussian',
list(n_nodes = 35, init_val = rep(0.5, 20), period = 90))
test_results
test_results$estimates
test_results = fitOneFactorDynamic(df = unif_df[1:500,1:20], copula = 'Clayton',
list(n_nodes = 25, init_val = rep(2, 20), period = 90))
devtools::build()
devtools::install()
################################################
#test dynamic model
test_results = fitOneFactorDynamic(df = unif_df[1:200,1:20], copula = 'Gaussian',
list(n_nodes = 35, init_val = rep(0.5, 20), period = 90))
test_results = fitOneFactorDynamic(df = unif_df[1:500,1:20], copula = 'Clayton',
list(n_nodes = 25, init_val = rep(2, 20), period = 90))
devtools::build()
devtools::install()
library(DDFactorCopula)
################################################
#test dynamic model
test_results = fitOneFactorDynamic(df = unif_df[1:200,1:20], copula = 'Gaussian',
list(n_nodes = 35, init_val = rep(0.5, 20), period = 90))
test_results = fitOneFactorDynamic(df = unif_df[1:500,1:20], copula = 'Clayton',
list(n_nodes = 25, init_val = rep(2, 20), period = 90))
test_results = fitOneFactorDynamic(df = unif_df[1:500,1:20], copula = 'Clayton',
list(n_nodes = 25, init_val = rep(2, 20), period = 90))
devtools::build()
devtools::install()
test_results = fitOneFactorDynamic(df = unif_df[1:500,1:20], copula = 'Clayton',
list(n_nodes = 25, init_val = rep(2, 20), period = 90))
warnings()
test_results
test_results$estimates
test_results$gradients
test_results = fitOneFactorDynamic(df = unif_df[1:200,1:20], copula = 'Gumbel',
list(n_nodes = 25, init_val = rep(2, 20), period = 90))
devtools::build()
devtools::install()
library(DDFactorCopula)
test_results = fitOneFactorDynamic(df = unif_df[1:200,1:20], copula = 'Gumbel',
list(n_nodes = 25, init_val = rep(2, 20), period = 90))
devtools::build()
devtools::install()
library(DDFactorCopula)
test_results = fitOneFactorDynamic(df = unif_df[1:200,1:20], copula = 'Gumbel',
list(n_nodes = 25, init_val = rep(2, 20), period = 90))
test_results
test_results$estimates
test_results = fitOneFactorDynamic(df = unif_df[1:200,1:20], copula = 'rGumbel',
list(n_nodes = 25, init_val = rep(2, 20), period = 90))
?fitOneFactorDynamic
test_results = fitOneFactorDynamic(df = unif_df[1:200,1:20], copula = 'rGumbel',
list(n_nodes = 25))
devtools::build()
devtools::install()
library(DDFactorCopula)
test_results = fitOneFactorDynamic(df = unif_df[1:200,1:20], copula = 'Gumbel',
list(period = 90))
test_results
test_results = fitOneFactorDynamic(df = unif_df[1:200,1:20], copula = 'rGumbel',
list(n_nodes = 25))
devtools::document()
devtools::build()
devtools::install()
devtools::install()
################################################
#test tail weighted measure of dependence function
test_results = powerTailDependence(unif_df[,1:20], d = 6, p = 0.5)
test_results
devtools::document()
devtools::build()
devtools::document()
devtools::document()
devtools::build()
devtools::install()
?DDFactorCopula
library(DDFactorCopula)
################################################
#test AIC BIC functions
test_results = computeAIC(12000, 3)
test_results
test_results = computeBIC(12000, 3, 1000)
test_results
r1factor(n = nrow(tmp),  d1 = (ncol(tmp)), theta = result_gaussian_90_days$estimates[[i]], copF1 = rep('bvn', (ncol(tmp))))
?r1factor
Map(function(x,y) mat <- matrix(c(x, y), nrow = 1, ncol = 2), result_clayton_90_days$estimates[[i]], rep(1, ncol(tmp)))
Map(function(x,y) mat <- matrix(c(x, y), nrow = 1, ncol = 2), rep(2, 29), rep(1, 20)
)
load("/Users/ruiliu/Desktop/research/results/result_clayton_90_days.RData")
Map(function(x,y) mat <- matrix(c(x, y), nrow = 1, ncol = 2), result_clayton_90_days$estimates[[i]], rep(1, ncol(tmp)))
i = 1
Map(function(x,y) mat <- matrix(c(x, y), nrow = 1, ncol = 2), result_clayton_90_days$estimates[[i]], rep(1, ncol(tmp)))
result_clayton_90_days[[1]]
devtools::document()
#'
#' This function simulates from a one factor copula model
#'
#' @param n number of observations to simulate
#' @param copula the copula to simulate from, can be one of Gaussian, Clayton, Gumbel and rGumbel
#' @param d number of variables
#' @param theta the copula parameters as a vector
#' @importFrom FactorCopula r1factor
#' @return A ncol(df) x ncol(df) matrix containing the tail weighted measure of dependence between the variables
#' @export
simulateOneFactor = function(n, copula, d, theta){
devtools::document()
devtools::build()
devtools::install()
library(DDFactorCopula)
################################################
#test generate function
simulateOneFactor(1000, "Gaussian", 20, rep(2.5, 20))
r1factor(n = 1000, d1 = 20, theta = rep(2.5,20), copF1 = rep('bvn', 20))
warnings()
result_clayton_90_days$estimates[[1]]
result_clayton_90_days$estimates[[1]]/2
result_clayton_90_days$estimates[[1]]/3
################################################
#test generate function
simulateOneFactor(1000, "Gaussian", 8, c(0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8))
test_results = simulateOneFactor(1000, "Clayton", 8, c(1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8))
test_results
test_results = simulateOneFactor(1000, "Gumbel", 8, c(1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8))
test_results
test_results = simulateOneFactor(1000, "rGumbel", 8, c(1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8))
test_results
library(DDFactorCopula)
unif_df = read.csv('/Users/ruiliu/Desktop/research/data/unif_df.csv')
################################################
#test base model
test_results = fitOneFactor(df = unif_df[,1:20],copula = "Gaussian",
list(n_nodes = 35))
test_results = fitOneFactor(df = unif_df[,1:20],copula = "Clayton",
list(n_nodes = 35, init_val = rep(2, 20)))
test_results = fitOneFactor(df = unif_df[,1:20],copula = "Gumbel",
list(n_nodes = 35, init_val = rep(3, 20)))
test_results = fitOneFactor(df = unif_df[,1:20],copula = "rGumbel",
list(n_nodes = 35, init_val = rep(1, 20)))
################################################
#test dynamic model
test_results = fitOneFactorDynamic(df = unif_df[1:200,1:20], copula = 'Gaussian',
list(n_nodes = 35, init_val = rep(0.5, 20), period = 90))
test_results = fitOneFactorDynamic(df = unif_df[1:200,1:20], copula = 'Clayton',
list(n_nodes = 25, init_val = rep(2, 20), period = 90))
test_results = fitOneFactorDynamic(df = unif_df[1:200,1:20], copula = 'Gumbel',
list(period = 90))
test_results = fitOneFactorDynamic(df = unif_df[1:200,1:20], copula = 'rGumbel',
list(n_nodes = 25))
################################################
#test tail weighted measure of dependence function
test_results = powerTailDependence(unif_df[,1:20], d = 6, p = 0.5)
################################################
#test AIC BIC functions
test_results = computeAIC(12000, 3)
test_results = computeBIC(12000, 3, 1000)
################################################
#test generate function
test_results = simulateOneFactor(1000, "Gaussian", 8, c(0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8))
test_results = simulateOneFactor(1000, "Clayton", 8, c(1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8))
test_results = simulateOneFactor(1000, "Gumbel", 8, c(1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8))
test_results = simulateOneFactor(1000, "rGumbel", 8, c(1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8))
test_results
